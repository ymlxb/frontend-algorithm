
最长递增子序列的动态规划解法
最长递增子序列（LIS）的动态规划解法是一种经典的算法设计方法，其核心思想是通过数学归纳法逐步构建问题的解。以下是详细的步骤和解释：
定义状态：
设dp[i]表示以数组中第i个元素结尾的最长递增子序列的长度。每个元素本身可以构成一个长度为 1 的子序列，因此dp数组的初始值都为 1。
状态转移方程：
对于每个i（从 1 到数组长度 - 1），遍历其前面的所有元素j（从 0 到i-1）。
如果nums[j] < nums[i]，说明可以将nums[i]添加到以nums[j]结尾的递增子序列中，形成一个更长的子序列。此时，dp[i]的值更新为dp[j] + 1和当前dp[i]中的较大值。
状态转移方程为：dp[i] = max(dp[i], dp[j] + 1)，其中j < i且nums[j] < nums[i]。
最终结果：
遍历整个dp数组，找到其中的最大值，即为最长递增子序列的长度。
示例：
输入数组：[10, 9, 2, 5, 3, 7, 101, 18]
计算过程：
dp[0] = 1（以 10 结尾的子序列长度为 1）
dp[1] = 1（9 不大于前面的 10，无法形成更长的子序列）
dp[2] = 1（2 不大于前面的 10 和 9）
dp[3] = 2（5 大于 2，可以添加到以 2 结尾的子序列中）
dp[4] = 2（3 大于 2）
dp[5] = 3（7 大于 2、5、3）
dp[6] = 4（101 大于前面所有较小的元素）
dp[7] = 4（18 大于前面的部分元素，但无法形成更长的子序列）
最终结果：4（最长递增子序列为[2, 3, 7, 101]）。
复杂度分析：
时间复杂度：O (n²)，其中 n 是数组的长度。需要两层循环来计算dp数组。
空间复杂度：O (n)，主要用于存储dp数组。


## 为什么在 LIS 问题中要初始化为 1？
因为对于最长递增子序列问题：

每个元素自身至少可以构成一个长度为 1 的递增子序列

dp[i] 表示以 nums[i] 结尾的最长递增子序列长度

最短的情况就是只包含 nums[i] 自己，所以初始值都是 1
```js
var lengthOfLIS = function(nums) {
    if (nums.length === 0) return 0;
    const dp = new Array(nums.length).fill(1);
    for (let i = 0; i< nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return Math.max(...dp);
};
```