连续子数组最大和
连续子数组的最大和问题可以通过动态规划方法高效解决，时间复杂度为 O (n)。以下是具体步骤：
定义状态：设dp[i]表示以第i个元素结尾的连续子数组的最大和。
状态转移方程：
对于每个元素nums[i]，有两种选择：
将其加入前一个子数组：dp[i-1] + nums[i]
以当前元素作为新的子数组开头：nums[i]
因此，状态转移方程为：dp[i] = max(dp[i-1] + nums[i], nums[i])。
初始条件：第一个元素的最大子数组和即为其本身：dp[0] = nums[0]。
求解过程：
遍历数组，依次计算每个位置的dp[i]。
同时，记录所有dp[i]中的最大值作为最终结果。
示例：
对于数组[1, -2, 3, 10, -4, 7, 2, -5]：
dp[0] = 1
dp[1] = max(1 + (-2), -2) = -1
dp[2] = max(-1 + 3, 3) = 3
dp[3] = max(3 + 10, 10) = 13
dp[4] = max(13 + (-4), -4) = 9
dp[5] = max(9 + 7, 7) = 16
dp[6] = max(16 + 2, 2) = 18
dp[7] = max(18 + (-5), -5) = 13
最终，最大子数组和为18。

```js
function maxSubArray(nums) {
  if (nums.length === 0) return 0;
  let dp = [nums[0]]
  for (let i = 1; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
  } 
  return Math.max(...dp);
}

console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]));

```