
## 引言
前端常见的三个效果案例均使用 Intersection Observer API 实现：图片懒加载（仅当图片被看到时加载真实图片，节省带宽）、瀑布流加载更多（加载指示器与视口交叉时加载新内容）、广告播放控制（广告元素 60% 以上在视口内时播放，否则暂停）。该 API 称为交叉观察器，用于观察元素与指定容器（通常为视口）的交叉情况。

## 交叉观察器的概念
交叉观察器用于检测目标元素与指定容器（root）是否存在交叉区域。核心场景包括：元素是否被用户“看到”（与视口交叉）、交叉比例变化时触发逻辑（如加载、播放/暂停）。默认观察目标元素与视口的交叉情况。

## 交叉观察器的使用
创建观察器  
  通过创建实例。为交叉状态变化时的回调函数，为配置项（可选）。
配置项  
  root：指定观察目标元素的容器，默认为（即视口），可配置为目标元素的父 / 祖先元素。

  rootMargin：容器边界的扩展 / 收缩值（如表示容器向外扩展 10px，表示向内收缩 10px），默认（容器边界无扩展 / 收缩）。

  threshold：交叉阈值（0-1），表示目标元素与容器交叉比例达到该值时触发回调。如（目标元素刚接触容器边界时触发）、（完全交叉时触发）、（60% 交叉时触发）。
回调函数与参数  
  回调函数接收参数（数组），每个 entry 包含目标元素的交叉信息：
  isIntersecting：布尔值，指示目标元素当前是否与容器交叉。
  target：当前被观察的 DOM 元素。
  观察多个元素时，回调会合并处理，通过数组可获取所有目标元素的交叉状态。

  ## 实现
  ```js
    const ob = new IntersectionObserver {
      (entries) => {  // 这个函数的 entries 参数是一个数组包含了每一张图片，就是要观察的目标，每一个目标元素的交叉情况都在里面
        // console.log('交叉情况变化了');
        for (const entry of entries) {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src; 
            ob.unobserve(img);  // 图片加载后取消观察
          }
        }
      },
      {
        // root: null,  // 视口
        // rootMargin: '0px',
        threshold: 0,  // 交叉的阈值 0 - 1
      }
    }

    const imgs = document.querySelectorAll('img');
    imgs.forEach(img => {
      ob.observe(img);
    })

  ```