
1. 存储结构：使用 Map 或 Object 存储事件名和对应的回调函数数组 
2. 订阅(on)：将回调函数添加到对应事件的数组中
3. 发布(event)：遍历执行对应事件的所有回调函数
4. 取消订阅(off)：从回调函数数组中移除指定的函数
5. 一次性订阅(once)：包装回调函数，在执行后自动取消订阅

```js
// 发布订阅模式

const EventBus = {
  events: {},

  on(event, fn) {
    (this.events[event] || (this.events[event] = [])).push(fn)
  },

  emit(event, ...args) {
    this.events[event]?.forEach(fn => fn(...args))
  },

  off(event, fn) {
    this.events[event] = this.events[event]?.filter(f => f !== fn)
  }
}

console.log('=== 1. 基础订阅发布测试 ===')

// 测试 1: 基本订阅发布
EventBus.on('message', (msg) => {
  console.log('监听器1收到消息:', msg)
})

EventBus.on('message', (msg) => {
  console.log('监听器2收到消息:', msg)
})

console.log('发布消息:')
EventBus.emit('message', 'Hello World!')
// 预期输出:
// 监听器1收到消息: Hello World!
// 监听器2收到消息: Hello World!

// 测试 2: 传递多个参数
EventBus.on('user', (name, age, city) => {
  console.log(`用户信息: ${name}, ${age}岁, 来自${city}`)
})

console.log('\n发布带多个参数的事件:')
EventBus.emit('user', '张三', 25, '北京')
// 预期输出: 用户信息: 张三, 25岁, 来自北京
console.log('\n=== 2. 取消订阅测试 ===')

// 定义要取消的回调函数
const callbackToRemove = (msg) => {
  console.log('这个回调会被移除:', msg)
}

const anotherCallback = (msg) => {
  console.log('这个回调会保留:', msg)
}

// 订阅事件
EventBus.on('test', callbackToRemove)
EventBus.on('test', anotherCallback)

console.log('第一次发布:')
EventBus.emit('test', '第一次触发')
// 预期输出:
// 这个回调会被移除: 第一次触发
// 这个回调会保留: 第一次触发

// 取消订阅特定的回调
EventBus.off('test', callbackToRemove)

console.log('取消后再次发布:')
EventBus.emit('test', '第二次触发')
// 预期输出:
// 这个回调会保留: 第二次触发
// (注意: "这个回调会被移除" 不会出现)
```